"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateopenmate_ui"]("main_window",{

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n// =======================\n// State Management\n// =======================\nconst AppState = {\n  repos: [],\n  collections: [],\n\n  setRepos(repos) {\n    this.repos = repos;\n  },\n\n  setCollections(collections) {\n    this.collections = collections;\n  },\n\n  getFilteredRepos(searchTerm) {\n    return this.filterItems(this.repos, searchTerm);\n  },\n\n  getFilteredCollections(searchTerm) {\n    return this.filterItems(this.collections, searchTerm);\n  },\n\n  filterItems(items, searchTerm) {\n    if (!searchTerm) return items;\n    const term = searchTerm.toLowerCase();\n    return items.filter(\n      (item) =>\n        item.name.toLowerCase().includes(term) ||\n        (item.path && item.path.toLowerCase().includes(term)) ||\n        (item.repos && item.repos.toLowerCase().includes(term))\n    );\n  },\n};\n\n// =======================\n// Utility Functions\n// =======================\nconst Utils = {\n  formatPath(path) {\n    return path ? path.replace(/\\\\/g, \"/\") : \"\";\n  },\n\n  debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => {\n        clearTimeout(timeout);\n        func(...args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  },\n\n  createElement(tag, attributes = {}, children = []) {\n    const element = document.createElement(tag);\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (key === \"className\") {\n        element.className = value;\n      } else {\n        element.setAttribute(key, value);\n      }\n    });\n    children.forEach((child) => {\n      if (typeof child === \"string\") {\n        element.appendChild(document.createTextNode(child));\n      } else {\n        element.appendChild(child);\n      }\n    });\n    return element;\n  },\n};\n\n// =======================\n// Storage Management\n// =======================\nconst Storage = {\n  THEME_KEY: \"openmate-theme\",\n  IDE_KEY: \"openmate-ide-selector\",\n\n  get(key) {\n    try {\n      return localStorage.getItem(key);\n    } catch (e) {\n      console.warn(\"Storage get failed:\", e);\n      return null;\n    }\n  },\n\n  set(key, value) {\n    try {\n      localStorage.setItem(key, value);\n    } catch (e) {\n      console.warn(\"Storage set failed:\", e);\n    }\n  },\n};\n\n// =======================\n// Theme Management\n// =======================\nconst ThemeManager = {\n  init() {\n    this.themeToggle = document.getElementById(\"theme-toggle\");\n    this.themeIcon = document.querySelector(\".theme-icon\");\n\n    this.loadTheme();\n    this.bindEvents();\n  },\n\n  loadTheme() {\n    const savedTheme = Storage.get(Storage.THEME_KEY);\n    const systemPrefersDark = window.matchMedia(\n      \"(prefers-color-scheme: dark)\"\n    ).matches;\n    const theme = savedTheme || (systemPrefersDark ? \"dark\" : \"light\");\n\n    this.setTheme(theme);\n  },\n\n  setTheme(theme) {\n    document.documentElement.setAttribute(\"data-theme\", theme);\n    this.themeIcon.textContent = theme === \"dark\" ? \"‚òÄÔ∏è\" : \"üåô\";\n    Storage.set(Storage.THEME_KEY, theme);\n  },\n\n  toggle() {\n    const currentTheme = document.documentElement.getAttribute(\"data-theme\");\n    const newTheme = currentTheme === \"dark\" ? \"light\" : \"dark\";\n    this.setTheme(newTheme);\n  },\n\n  bindEvents() {\n    this.themeToggle.addEventListener(\"click\", () => this.toggle());\n  },\n};\n\n// =======================\n// IDE Selector Management\n// =======================\nconst IDEManager = {\n  init() {\n    this.selector = document.getElementById(\"ide-selector\");\n    this.loadPreference();\n    this.bindEvents();\n  },\n\n  loadPreference() {\n    const savedIDE = Storage.get(Storage.IDE_KEY);\n    if (savedIDE) {\n      this.selector.value = savedIDE;\n    }\n  },\n\n  getSelectedIDE() {\n    return this.selector.value;\n  },\n\n  bindEvents() {\n    this.selector.addEventListener(\"change\", (e) => {\n      const selectedIDE = e.target.value;\n      if (selectedIDE) {\n        Storage.set(Storage.IDE_KEY, selectedIDE);\n        NotificationManager.showSuccess(`Default IDE set to ${selectedIDE}`);\n      }\n    });\n  },\n};\n\n// =======================\n// Notification Management\n// =======================\nconst NotificationManager = {\n  show(message, type = \"info\", duration = 3000) {\n    const colors = {\n      success: \"#4CAF50\",\n      error: \"#F44336\",\n      info: \"#2196F3\",\n    };\n\n    const notification = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        bottom: 20px;\n        right: 20px;\n        padding: 10px 20px;\n        background: ${colors[type]};\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n        transition: opacity 0.3s ease;\n      `,\n      },\n      [message]\n    );\n\n    document.body.appendChild(notification);\n\n    setTimeout(() => {\n      notification.style.opacity = \"0\";\n      setTimeout(() => {\n        if (document.body.contains(notification)) {\n          document.body.removeChild(notification);\n        }\n      }, 300);\n    }, duration);\n  },\n\n  showSuccess(message) {\n    this.show(message, \"success\");\n  },\n\n  showError(message) {\n    this.show(message, \"error\");\n  },\n\n  showInfo(message) {\n    this.show(message, \"info\");\n  },\n};\n\n// =======================\n// Modal Management\n// =======================\nclass Modal {\n  constructor(modalId, formId, openBtnId) {\n    this.modal = document.getElementById(modalId);\n    this.form = document.getElementById(formId);\n    this.openBtn = document.getElementById(openBtnId);\n    this.closeBtn = this.modal.querySelector(\".close\");\n\n    this.bindEvents();\n  }\n\n  bindEvents() {\n    this.openBtn?.addEventListener(\"click\", () => this.open());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n\n    // Close on outside click\n    window.addEventListener(\"click\", (e) => {\n      if (e.target === this.modal) {\n        this.close();\n      }\n    });\n\n    // Close on Escape key\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Escape\" && this.isOpen()) {\n        this.close();\n      }\n    });\n  }\n\n  open() {\n    this.modal.style.display = \"flex\";\n    document.body.style.overflow = \"hidden\";\n    this.onOpen();\n  }\n\n  close() {\n    this.modal.style.display = \"none\";\n    document.body.style.overflow = \"auto\";\n    this.form?.reset();\n    this.onClose();\n  }\n\n  isOpen() {\n    return this.modal.style.display === \"flex\";\n  }\n\n  onOpen() {\n    // Override in subclasses\n  }\n\n  onClose() {\n    // Override in subclasses\n  }\n}\n\n// =======================\n// Repository Modal\n// =======================\nclass RepositoryModal extends Modal {\n  constructor() {\n    super(\"add-repo-modal\", \"add-repo-form\", \"add-repo-btn\");\n    this.nameInput = document.getElementById(\"repo-name\");\n    this.pathInput = document.getElementById(\"repo-path\");\n    this.browseBtn = document.getElementById(\"browse-path\");\n\n    this.bindRepositoryEvents();\n  }\n\n  onOpen() {\n    this.nameInput.focus();\n  }\n\n  bindRepositoryEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn.addEventListener(\"click\", () => this.browsePath());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const path = this.pathInput.value.trim();\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      await window.electronAPI.addRepository({ name, path });\n      this.close();\n      NotificationManager.showSuccess(\"Repository added successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error adding repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name || !path) {\n      NotificationManager.showError(\"Please fill in all fields\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Repository Modal\n// =======================\nclass EditRepositoryModal extends Modal {\n  constructor() {\n    super(\"edit-repo-modal\", \"edit-repo-form\");\n    this.nameInput = document.getElementById(\"edit-repo-name\");\n    this.pathInput = document.getElementById(\"edit-repo-path\");\n    this.originalNameInput = document.getElementById(\"edit-original-name\");\n    this.browseBtn = document.getElementById(\"edit-browse-path\");\n    this.closeBtn = document.querySelector(\"#edit-repo-modal .close\");\n\n    this.bindEvents();\n  }\n\n  open(repo) {\n    // Store original values\n    this.originalNameInput.value = repo.name;\n\n    // Set current values (read-only)\n    document.getElementById(\"current-repo-name\").textContent = repo.name;\n    document.getElementById(\"current-repo-path\").textContent = repo.path;\n\n    // Clear and reset form fields\n    this.nameInput.value = repo.name;\n    this.pathInput.value = repo.path;\n    this.nameInput.placeholder = `Current: ${repo.name}`;\n    this.pathInput.placeholder = `Current: ${repo.path}`;\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn?.addEventListener(\"click\", () => this.browsePath());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim() || originalName; // Use original name if new name is empty\n    const path =\n      this.pathInput.value.trim() ||\n      this.pathInput.placeholder.replace(\"Current: \", \"\"); // Use current path if empty\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      // Get current repositories data\n      const data = await window.electronAPI.getReposData();\n\n      // Ensure we have the expected data structure\n      if (!data || typeof data !== \"object\" || !data.repos) {\n        throw new Error(\"Invalid repository data structure\");\n      }\n\n      console.log(\"Current repositories:\", data.repos); // Debug log\n      console.log(\"Looking for repository with name:\", originalName); // Debug log\n\n      // Check if the repository exists\n      if (!data.repos[originalName]) {\n        console.error(\"Repository not found in:\", data.repos);\n        throw new Error(\"Repository not found\");\n      }\n\n      // Check if name is being changed to an existing one (except current repo)\n      if (name !== originalName && data.repos[name]) {\n        NotificationManager.showError(\n          \"A repository with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the repositories\n      const updatedRepos = { ...data.repos };\n\n      // If name changed, remove old entry\n      if (name !== originalName) {\n        delete updatedRepos[originalName];\n      }\n\n      // Update or add the repository with new values and updatedAt timestamp\n      const now = new Date().toISOString();\n      updatedRepos[name] = {\n        path,\n        updatedAt: data.repos[originalName]?.updatedAt || now,\n      };\n\n      // Save the updated repositories using the correct IPC method\n      await window.electronAPI.writeReposFile({\n        ...data,\n        repos: updatedRepos,\n      });\n\n      // Refresh UI\n      UIManager.refresh();\n\n      NotificationManager.showSuccess(\"Repository updated successfully\");\n      this.close();\n    } catch (error) {\n      console.error(\"Error updating repository:\", error);\n      NotificationManager.showError(\n        `Failed to update repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a repository name\");\n      return false;\n    }\n    if (!path) {\n      NotificationManager.showError(\"Please select a repository path\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Collection Modal\n// =======================\nclass EditCollectionModal extends Modal {\n  constructor() {\n    super(\"edit-collection-modal\", \"edit-collection-form\");\n    this.nameInput = document.getElementById(\"edit-collection-name\");\n    this.originalNameInput = document.getElementById(\n      \"edit-original-collection-name\"\n    );\n    this.currentNameEl = document.getElementById(\"current-collection-name\");\n    this.currentReposEl = document.getElementById(\"current-collection-repos\");\n    this.reposSelection = document.getElementById(\"edit-repos-selection\");\n    this.closeBtn = document.querySelector(\"#edit-collection-modal .close\");\n\n    this.bindEvents();\n  }\n\n  async open(collection) {\n    // Store original values\n    this.originalNameInput.value = collection.name;\n\n    // Set current values\n    this.currentNameEl.textContent = collection.name;\n\n    // Handle both array and string formats for backward compatibility\n    const repoList = Array.isArray(collection.repos)\n      ? collection.repos\n      : (collection.repos || \"\")\n          .split(\",\")\n          .map((s) => s.trim())\n          .filter(Boolean);\n\n    this.currentReposEl.textContent = repoList.length\n      ? repoList.join(\", \")\n      : \"No repositories\";\n    this.nameInput.value = collection.name;\n    this.nameInput.placeholder = `Current: ${collection.name}`;\n\n    // Load repositories with current selection\n    await this.loadRepositories(repoList);\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async loadRepositories(selectedRepos = []) {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {}, selectedRepos);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos, selectedRepos = []) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"edit-repo-${name}\" name=\"repos\" value=\"${name}\" \n                 ${selectedRepos.includes(name) ? \"checked\" : \"\"}>\n          <label for=\"edit-repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      const data = await window.electronAPI.getReposData();\n\n      // Check if name is being changed to an existing one (except current collection)\n      if (name !== originalName && data.collections && data.collections[name]) {\n        NotificationManager.showError(\n          \"A collection with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the collections\n      const updatedCollections = { ...data.collections };\n\n      // Remove old entry if name changed\n      if (name !== originalName) {\n        delete updatedCollections[originalName];\n      }\n\n      // Update or add the collection with new values\n      updatedCollections[name] = {\n        name,\n        repos: selectedRepos, // Save as array\n        updatedAt:\n          updatedCollections[originalName]?.updatedAt ||\n          new Date().toISOString(),\n      };\n\n      // Save the updated collections\n      await window.electronAPI.writeReposFile({\n        ...data,\n        collections: updatedCollections,\n      });\n\n      this.close();\n      NotificationManager.showSuccess(\"Collection updated successfully\");\n      UIManager.refresh();\n    } catch (error) {\n      console.error(\"Error updating collection:\", error);\n      NotificationManager.showError(\n        `Failed to update collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n}\n\n// =======================\n// Collection Modal\n// =======================\nclass CollectionModal extends Modal {\n  constructor() {\n    super(\"add-collection-modal\", \"add-collection-form\", \"add-collection-btn\");\n    this.nameInput = document.getElementById(\"collection-name\");\n    this.reposSelection = document.getElementById(\"repos-selection\");\n\n    this.bindCollectionEvents();\n  }\n\n  async onOpen() {\n    this.nameInput.focus();\n    await this.loadRepositories();\n  }\n\n  onClose() {\n    this.reposSelection.innerHTML =\n      '<div class=\"loading\">Loading repositories...</div>';\n  }\n\n  bindCollectionEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n  }\n\n  async loadRepositories() {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {});\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"repo-${name}\" name=\"repos\" value=\"${name}\">\n          <label for=\"repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      await this.saveCollection(name, selectedRepos);\n      this.close();\n      NotificationManager.showSuccess(\"Collection created successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error creating collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n\n  async saveCollection(name, selectedRepos) {\n    const data = await window.electronAPI.getReposData();\n\n    if (data.collections && data.collections[name]) {\n      throw new Error(\"A collection with this name already exists\");\n    }\n\n    if (!data.collections) data.collections = {};\n    data.collections[name] = {\n      name,\n      repos: selectedRepos,\n      updatedAt: new Date().toISOString(),\n    };\n\n    await window.electronAPI.writeReposFile(data);\n  }\n}\n\n// =======================\n// UI Management\n// =======================\nconst UIManager = {\n  init(callbacks = {}) {\n    this.searchInput = document.getElementById(\"search-input\");\n    this.refreshBtn = document.getElementById(\"refresh-btn\");\n\n    // Store callbacks\n    this.handleEditRepository = callbacks.onEditRepository || (() => {});\n    this.handleEditCollection = callbacks.onEditCollection || (() => {});\n\n    // Initialize edit collection modal if it doesn't exist\n    if (!this.editCollectionModal) {\n      this.editCollectionModal = new EditCollectionModal();\n    }\n\n    this.bindEvents();\n    this.refresh();\n  },\n\n  bindEvents() {\n    // Debounce search to improve performance\n    const debouncedUpdate = Utils.debounce(() => this.updateDisplay(), 300);\n    this.searchInput.addEventListener(\"input\", debouncedUpdate);\n    this.refreshBtn.addEventListener(\"click\", () => this.refresh());\n  },\n\n  async refresh() {\n    this.showRefreshAnimation();\n\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.processData(data);\n      this.updateDisplay();\n    } catch (error) {\n      NotificationManager.showError(`Error refreshing data: ${error.message}`);\n    } finally {\n      this.hideRefreshAnimation();\n    }\n  },\n\n  processData(data) {\n    // Process repositories\n    if (data.repos) {\n      const repos = Object.entries(data.repos).map(([name, repo]) => ({\n        name,\n        path: repo.path,\n        updatedAt: repo.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setRepos(repos);\n    } else {\n      AppState.setRepos([]);\n    }\n\n    // Process collections\n    if (data.collections) {\n      const collections = Object.values(data.collections).map((collection) => ({\n        name: collection.name,\n        repos: Array.isArray(collection.repos)\n          ? collection.repos.join(\", \")\n          : \"\",\n        updatedAt: collection.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setCollections(collections);\n    } else {\n      AppState.setCollections([]);\n    }\n  },\n\n  updateDisplay() {\n    const searchTerm = this.searchInput.value.trim();\n    this.updateRepositoriesTable(AppState.getFilteredRepos(searchTerm));\n    this.updateCollectionsTable(AppState.getFilteredCollections(searchTerm));\n  },\n\n  updateRepositoriesTable(repos) {\n    const container = document.getElementById(\"repos-list\");\n    const table = document.getElementById(\"repos-table\");\n    const loading = document.getElementById(\"loading-repos\");\n\n    if (repos.length === 0) {\n      loading.textContent = \"No matching repositories found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = repos\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((repo) => this.createRepositoryRow(repo))\n      .join(\"\");\n\n    this.bindRepositoryEvents();\n  },\n\n  createRepositoryRow(repo) {\n    return `\n      <tr data-path=\"${Utils.formatPath(repo.path)}\" data-name=\"${repo.name}\" class=\"clickable-repo-row\">\n        <td><strong>${repo.name}</strong></td>\n        <td class=\"path\">${Utils.formatPath(repo.path)}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${repo.name}\" data-path=\"${Utils.formatPath(repo.path)}\" data-type=\"repo\" title=\"Edit repository\">‚úèÔ∏è</button>\n            <button class=\"delete-btn\" data-name=\"${repo.name}\" data-type=\"repo\" title=\"Delete repository\">üóëÔ∏è</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindRepositoryEvents() {\n    // Bind click events for opening repositories\n    document.querySelectorAll(\".clickable-repo-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleRepositoryClick(e, row));\n    });\n\n    // Bind edit events\n    document.querySelectorAll('.edit-btn[data-type=\"repo\"]').forEach((btn) => {\n      btn.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        const name = btn.dataset.name;\n        const path = btn.dataset.path;\n        if (this.handleEditRepository) {\n          this.handleEditRepository({ name, path });\n        }\n      });\n    });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"repo\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleRepositoryDelete(e, btn)\n        );\n      });\n  },\n\n  async handleRepositoryClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    const selectedIDE = IDEManager.getSelectedIDE();\n    if (!selectedIDE) {\n      NotificationManager.showError(\"Please select an IDE first\");\n      return;\n    }\n\n    const repoPath = row.getAttribute(\"data-path\");\n    const repoName = row.getAttribute(\"data-name\");\n    console.log(repoPath, repoName);\n    if (!repoPath) return;\n\n    try {\n      const result = await window.electronAPI.openInIDE({\n        name: repoName,\n        path: repoPath,\n        ide: selectedIDE,\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || \"Failed to open in IDE\");\n      }\n\n      NotificationManager.showSuccess(\n        `Successfully opened ${repoPath} in ${selectedIDE}`\n      );\n    } catch (error) {\n      NotificationManager.showError(`Error opening IDE: ${error.message}`);\n    }\n  },\n\n  async handleRepositoryDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete repository \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteRepo(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  updateCollectionsTable(collections) {\n    const container = document.getElementById(\"collections-list\");\n    const table = document.getElementById(\"collections-table\");\n    const loading = document.getElementById(\"loading-collections\");\n\n    if (collections.length === 0) {\n      loading.textContent = \"No matching collections found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = collections\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((collection) => this.createCollectionRow(collection))\n      .join(\"\");\n\n    this.bindCollectionEvents();\n  },\n\n  createCollectionRow(collection) {\n    const collectionData = JSON.stringify(collection).replace(/\"/g, \"&quot;\");\n    return `\n      <tr class=\"clickable-collection-row\" data-collection=\"${collectionData}\">\n        <td><strong>${collection.name}</strong></td>\n        <td>${collection.repos}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Edit collection\">‚úèÔ∏è</button>\n            <button class=\"delete-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Delete collection\">üóëÔ∏è</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindCollectionEvents() {\n    // Bind click events for opening collections\n    document.querySelectorAll(\".clickable-collection-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleCollectionClick(e, row));\n    });\n\n    // Bind edit events\n    document\n      .querySelectorAll('.edit-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          const collectionData = JSON.parse(\n            btn\n              .closest(\"tr\")\n              .getAttribute(\"data-collection\")\n              .replace(/&quot;/g, '\"')\n          );\n          if (this.editCollectionModal) {\n            this.editCollectionModal.open(collectionData);\n          }\n        });\n      });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleCollectionDelete(e, btn)\n        );\n      });\n  },\n\n  async handleCollectionClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    try {\n      const collection = JSON.parse(row.getAttribute(\"data-collection\"));\n      const reposData = await window.electronAPI.getReposData();\n\n      const repos = collection.repos.split(\",\").map((repo) => {\n        const [name, path, ide] = repo\n          .trim()\n          .split(\"|\")\n          .map((s) => s.trim());\n        return { name, path, ide };\n      });\n\n      // Open all repositories in parallel\n      const promises = repos.map(async (repo) => {\n        const repoData = reposData.repos[repo.name];\n\n        if (!repoData) {\n          NotificationManager.showError(\n            `${repo.name}: Not found in repositories`\n          );\n          return;\n        }\n\n        const ide = repo.ide || IDEManager.getSelectedIDE();\n\n        try {\n          await window.electronAPI.openInIDE({\n            name: repo.name,\n            path: repoData.path,\n            ide: ide,\n          });\n        } catch (error) {\n          NotificationManager.showError(\n            `Failed to open ${repo.name}: ${error.message}`\n          );\n        }\n      });\n\n      await Promise.allSettled(promises);\n      NotificationManager.showSuccess(`Successfully opened ${collection.name}`);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error processing collection: ${error.message}`\n      );\n    }\n  },\n\n  async handleCollectionDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete collection \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteCollection(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  showRefreshAnimation() {\n    this.refreshBtn.classList.add(\"rotating\");\n  },\n\n  hideRefreshAnimation() {\n    setTimeout(() => {\n      this.refreshBtn.classList.remove(\"rotating\");\n    }, 1000);\n  },\n\n  showLoadingIndicator(text) {\n    const indicator = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        padding: 10px;\n        background: rgba(0,0,0,0.7);\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n      `,\n      },\n      [text]\n    );\n\n    document.body.appendChild(indicator);\n    return indicator;\n  },\n\n  hideLoadingIndicator(indicator) {\n    if (document.body.contains(indicator)) {\n      document.body.removeChild(indicator);\n    }\n  },\n};\n\n// =======================\n// Application Initialization\n// =======================\nclass App {\n  constructor() {\n    this.init();\n  }\n\n  init() {\n    // Initialize core systems\n    ThemeManager.init();\n    IDEManager.init();\n\n    // Initialize modals\n    this.repositoryModal = new RepositoryModal();\n    this.editRepositoryModal = new EditRepositoryModal();\n    this.collectionModal = new CollectionModal();\n    this.editCollectionModal = new EditCollectionModal();\n\n    // Initialize UI manager with modals\n    UIManager.init({\n      onEditRepository: (repo) => this.editRepositoryModal.open(repo),\n      onEditCollection: (collection) =>\n        this.editCollectionModal.open(collection),\n    });\n\n    // Handle electron API data\n    this.bindElectronEvents();\n\n    console.log(\"üëã OpenMate application initialized successfully\");\n  }\n\n  bindElectronEvents() {\n    if (window.electronAPI && window.electronAPI.onReposData) {\n      window.electronAPI.onReposData((data) => {\n        const { repos = [], collections = [] } = data;\n        AppState.setRepos(repos);\n        AppState.setCollections(collections);\n        UIManager.updateDisplay();\n      });\n    }\n  }\n}\n\n// =======================\n// Initialize Application\n// =======================\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new App();\n});\n\n// Import styles\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3FCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3Blbm1hdGUtdWkvLi9zcmMvcmVuZGVyZXIuanM/ODhjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU3RhdGUgTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IEFwcFN0YXRlID0ge1xuICByZXBvczogW10sXG4gIGNvbGxlY3Rpb25zOiBbXSxcblxuICBzZXRSZXBvcyhyZXBvcykge1xuICAgIHRoaXMucmVwb3MgPSByZXBvcztcbiAgfSxcblxuICBzZXRDb2xsZWN0aW9ucyhjb2xsZWN0aW9ucykge1xuICAgIHRoaXMuY29sbGVjdGlvbnMgPSBjb2xsZWN0aW9ucztcbiAgfSxcblxuICBnZXRGaWx0ZXJlZFJlcG9zKHNlYXJjaFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJJdGVtcyh0aGlzLnJlcG9zLCBzZWFyY2hUZXJtKTtcbiAgfSxcblxuICBnZXRGaWx0ZXJlZENvbGxlY3Rpb25zKHNlYXJjaFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJJdGVtcyh0aGlzLmNvbGxlY3Rpb25zLCBzZWFyY2hUZXJtKTtcbiAgfSxcblxuICBmaWx0ZXJJdGVtcyhpdGVtcywgc2VhcmNoVGVybSkge1xuICAgIGlmICghc2VhcmNoVGVybSkgcmV0dXJuIGl0ZW1zO1xuICAgIGNvbnN0IHRlcm0gPSBzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAgIChpdGVtKSA9PlxuICAgICAgICBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSB8fFxuICAgICAgICAoaXRlbS5wYXRoICYmIGl0ZW0ucGF0aC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pKSB8fFxuICAgICAgICAoaXRlbS5yZXBvcyAmJiBpdGVtLnJlcG9zLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkpXG4gICAgKTtcbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IFV0aWxzID0ge1xuICBmb3JtYXRQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aCA/IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikgOiBcIlwiO1xuICB9LFxuXG4gIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZWRGdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBmdW5jKC4uLmFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9O1xuICB9LFxuXG4gIGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRyaWJ1dGVzID0ge30sIGNoaWxkcmVuID0gW10pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc05hbWVcIikge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU3RvcmFnZSBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgU3RvcmFnZSA9IHtcbiAgVEhFTUVfS0VZOiBcIm9wZW5tYXRlLXRoZW1lXCIsXG4gIElERV9LRVk6IFwib3Blbm1hdGUtaWRlLXNlbGVjdG9yXCIsXG5cbiAgZ2V0KGtleSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTdG9yYWdlIGdldCBmYWlsZWQ6XCIsIGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlN0b3JhZ2Ugc2V0IGZhaWxlZDpcIiwgZSk7XG4gICAgfVxuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRoZW1lIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBUaGVtZU1hbmFnZXIgPSB7XG4gIGluaXQoKSB7XG4gICAgdGhpcy50aGVtZVRvZ2dsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGhlbWUtdG9nZ2xlXCIpO1xuICAgIHRoaXMudGhlbWVJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50aGVtZS1pY29uXCIpO1xuXG4gICAgdGhpcy5sb2FkVGhlbWUoKTtcbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgfSxcblxuICBsb2FkVGhlbWUoKSB7XG4gICAgY29uc3Qgc2F2ZWRUaGVtZSA9IFN0b3JhZ2UuZ2V0KFN0b3JhZ2UuVEhFTUVfS0VZKTtcbiAgICBjb25zdCBzeXN0ZW1QcmVmZXJzRGFyayA9IHdpbmRvdy5tYXRjaE1lZGlhKFxuICAgICAgXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCJcbiAgICApLm1hdGNoZXM7XG4gICAgY29uc3QgdGhlbWUgPSBzYXZlZFRoZW1lIHx8IChzeXN0ZW1QcmVmZXJzRGFyayA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcblxuICAgIHRoaXMuc2V0VGhlbWUodGhlbWUpO1xuICB9LFxuXG4gIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGhlbWVcIiwgdGhlbWUpO1xuICAgIHRoaXMudGhlbWVJY29uLnRleHRDb250ZW50ID0gdGhlbWUgPT09IFwiZGFya1wiID8gXCLimIDvuI9cIiA6IFwi8J+MmVwiO1xuICAgIFN0b3JhZ2Uuc2V0KFN0b3JhZ2UuVEhFTUVfS0VZLCB0aGVtZSk7XG4gIH0sXG5cbiAgdG9nZ2xlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaGVtZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRoZW1lXCIpO1xuICAgIGNvbnN0IG5ld1RoZW1lID0gY3VycmVudFRoZW1lID09PSBcImRhcmtcIiA/IFwibGlnaHRcIiA6IFwiZGFya1wiO1xuICAgIHRoaXMuc2V0VGhlbWUobmV3VGhlbWUpO1xuICB9LFxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy50aGVtZVRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy50b2dnbGUoKSk7XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSURFIFNlbGVjdG9yIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBJREVNYW5hZ2VyID0ge1xuICBpbml0KCkge1xuICAgIHRoaXMuc2VsZWN0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlkZS1zZWxlY3RvclwiKTtcbiAgICB0aGlzLmxvYWRQcmVmZXJlbmNlKCk7XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH0sXG5cbiAgbG9hZFByZWZlcmVuY2UoKSB7XG4gICAgY29uc3Qgc2F2ZWRJREUgPSBTdG9yYWdlLmdldChTdG9yYWdlLklERV9LRVkpO1xuICAgIGlmIChzYXZlZElERSkge1xuICAgICAgdGhpcy5zZWxlY3Rvci52YWx1ZSA9IHNhdmVkSURFO1xuICAgIH1cbiAgfSxcblxuICBnZXRTZWxlY3RlZElERSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci52YWx1ZTtcbiAgfSxcblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRJREUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgIGlmIChzZWxlY3RlZElERSkge1xuICAgICAgICBTdG9yYWdlLnNldChTdG9yYWdlLklERV9LRVksIHNlbGVjdGVkSURFKTtcbiAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhgRGVmYXVsdCBJREUgc2V0IHRvICR7c2VsZWN0ZWRJREV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTm90aWZpY2F0aW9uIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBOb3RpZmljYXRpb25NYW5hZ2VyID0ge1xuICBzaG93KG1lc3NhZ2UsIHR5cGUgPSBcImluZm9cIiwgZHVyYXRpb24gPSAzMDAwKSB7XG4gICAgY29uc3QgY29sb3JzID0ge1xuICAgICAgc3VjY2VzczogXCIjNENBRjUwXCIsXG4gICAgICBlcnJvcjogXCIjRjQ0MzM2XCIsXG4gICAgICBpbmZvOiBcIiMyMTk2RjNcIixcbiAgICB9O1xuXG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gVXRpbHMuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgYm90dG9tOiAyMHB4O1xuICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgcGFkZGluZzogMTBweCAyMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kOiAke2NvbG9yc1t0eXBlXX07XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZTtcbiAgICAgIGAsXG4gICAgICB9LFxuICAgICAgW21lc3NhZ2VdXG4gICAgKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm90aWZpY2F0aW9uKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbm90aWZpY2F0aW9uLnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhub3RpZmljYXRpb24pKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3RpZmljYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgIH0sIGR1cmF0aW9uKTtcbiAgfSxcblxuICBzaG93U3VjY2VzcyhtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KG1lc3NhZ2UsIFwic3VjY2Vzc1wiKTtcbiAgfSxcblxuICBzaG93RXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMuc2hvdyhtZXNzYWdlLCBcImVycm9yXCIpO1xuICB9LFxuXG4gIHNob3dJbmZvKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnNob3cobWVzc2FnZSwgXCJpbmZvXCIpO1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1vZGFsIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jbGFzcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKG1vZGFsSWQsIGZvcm1JZCwgb3BlbkJ0bklkKSB7XG4gICAgdGhpcy5tb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpO1xuICAgIHRoaXMuZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvcm1JZCk7XG4gICAgdGhpcy5vcGVuQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3BlbkJ0bklkKTtcbiAgICB0aGlzLmNsb3NlQnRuID0gdGhpcy5tb2RhbC5xdWVyeVNlbGVjdG9yKFwiLmNsb3NlXCIpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMub3BlbkJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMub3BlbigpKTtcbiAgICB0aGlzLmNsb3NlQnRuPy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5jbG9zZSgpKTtcblxuICAgIC8vIENsb3NlIG9uIG91dHNpZGUgY2xpY2tcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMubW9kYWwpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2Ugb24gRXNjYXBlIGtleVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy5pc09wZW4oKSkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMubW9kYWwuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHRoaXMub25PcGVuKCk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLm1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG4gICAgdGhpcy5mb3JtPy5yZXNldCgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGFsLnN0eWxlLmRpc3BsYXkgPT09IFwiZmxleFwiO1xuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIC8vIE92ZXJyaWRlIGluIHN1YmNsYXNzZXNcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgLy8gT3ZlcnJpZGUgaW4gc3ViY2xhc3Nlc1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSZXBvc2l0b3J5IE1vZGFsXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgUmVwb3NpdG9yeU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImFkZC1yZXBvLW1vZGFsXCIsIFwiYWRkLXJlcG8tZm9ybVwiLCBcImFkZC1yZXBvLWJ0blwiKTtcbiAgICB0aGlzLm5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwby1uYW1lXCIpO1xuICAgIHRoaXMucGF0aElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXBvLXBhdGhcIik7XG4gICAgdGhpcy5icm93c2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJyb3dzZS1wYXRoXCIpO1xuXG4gICAgdGhpcy5iaW5kUmVwb3NpdG9yeUV2ZW50cygpO1xuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIHRoaXMubmFtZUlucHV0LmZvY3VzKCk7XG4gIH1cblxuICBiaW5kUmVwb3NpdG9yeUV2ZW50cygpIHtcbiAgICB0aGlzLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZSkgPT4gdGhpcy5oYW5kbGVTdWJtaXQoZSkpO1xuICAgIHRoaXMuYnJvd3NlQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmJyb3dzZVBhdGgoKSk7XG4gIH1cblxuICBhc3luYyBoYW5kbGVTdWJtaXQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVJbnB1dC52YWx1ZS50cmltKCk7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aElucHV0LnZhbHVlLnRyaW0oKTtcblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cyhuYW1lLCBwYXRoKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5hZGRSZXBvc2l0b3J5KHsgbmFtZSwgcGF0aCB9KTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXCJSZXBvc2l0b3J5IGFkZGVkIHN1Y2Nlc3NmdWxseSFcIik7XG4gICAgICBVSU1hbmFnZXIucmVmcmVzaCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIGFkZGluZyByZXBvc2l0b3J5OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZUlucHV0cyhuYW1lLCBwYXRoKSB7XG4gICAgaWYgKCFuYW1lIHx8ICFwYXRoKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBmaWxsIGluIGFsbCBmaWVsZHNcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgYnJvd3NlUGF0aCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF0aCA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5vcGVuRGlyZWN0b3J5RGlhbG9nKCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB0aGlzLnBhdGhJbnB1dC52YWx1ZSA9IHBhdGg7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRXJyb3Igc2VsZWN0aW5nIGRpcmVjdG9yeTogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFZGl0IFJlcG9zaXRvcnkgTW9kYWxcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jbGFzcyBFZGl0UmVwb3NpdG9yeU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImVkaXQtcmVwby1tb2RhbFwiLCBcImVkaXQtcmVwby1mb3JtXCIpO1xuICAgIHRoaXMubmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlZGl0LXJlcG8tbmFtZVwiKTtcbiAgICB0aGlzLnBhdGhJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1yZXBvLXBhdGhcIik7XG4gICAgdGhpcy5vcmlnaW5hbE5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1vcmlnaW5hbC1uYW1lXCIpO1xuICAgIHRoaXMuYnJvd3NlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlZGl0LWJyb3dzZS1wYXRoXCIpO1xuICAgIHRoaXMuY2xvc2VCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2VkaXQtcmVwby1tb2RhbCAuY2xvc2VcIik7XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgfVxuXG4gIG9wZW4ocmVwbykge1xuICAgIC8vIFN0b3JlIG9yaWdpbmFsIHZhbHVlc1xuICAgIHRoaXMub3JpZ2luYWxOYW1lSW5wdXQudmFsdWUgPSByZXBvLm5hbWU7XG5cbiAgICAvLyBTZXQgY3VycmVudCB2YWx1ZXMgKHJlYWQtb25seSlcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnJlbnQtcmVwby1uYW1lXCIpLnRleHRDb250ZW50ID0gcmVwby5uYW1lO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3VycmVudC1yZXBvLXBhdGhcIikudGV4dENvbnRlbnQgPSByZXBvLnBhdGg7XG5cbiAgICAvLyBDbGVhciBhbmQgcmVzZXQgZm9ybSBmaWVsZHNcbiAgICB0aGlzLm5hbWVJbnB1dC52YWx1ZSA9IHJlcG8ubmFtZTtcbiAgICB0aGlzLnBhdGhJbnB1dC52YWx1ZSA9IHJlcG8ucGF0aDtcbiAgICB0aGlzLm5hbWVJbnB1dC5wbGFjZWhvbGRlciA9IGBDdXJyZW50OiAke3JlcG8ubmFtZX1gO1xuICAgIHRoaXMucGF0aElucHV0LnBsYWNlaG9sZGVyID0gYEN1cnJlbnQ6ICR7cmVwby5wYXRofWA7XG5cbiAgICAvLyBPcGVuIG1vZGFsIGFuZCBmb2N1c1xuICAgIHN1cGVyLm9wZW4oKTtcbiAgICB0aGlzLm5hbWVJbnB1dC5mb2N1cygpO1xuICB9XG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmZvcm0/LmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKGUpID0+IHRoaXMuaGFuZGxlU3VibWl0KGUpKTtcbiAgICB0aGlzLmJyb3dzZUJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuYnJvd3NlUGF0aCgpKTtcbiAgICB0aGlzLmNsb3NlQnRuPy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVN1Ym1pdChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxOYW1lID0gdGhpcy5vcmlnaW5hbE5hbWVJbnB1dC52YWx1ZTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lSW5wdXQudmFsdWUudHJpbSgpIHx8IG9yaWdpbmFsTmFtZTsgLy8gVXNlIG9yaWdpbmFsIG5hbWUgaWYgbmV3IG5hbWUgaXMgZW1wdHlcbiAgICBjb25zdCBwYXRoID1cbiAgICAgIHRoaXMucGF0aElucHV0LnZhbHVlLnRyaW0oKSB8fFxuICAgICAgdGhpcy5wYXRoSW5wdXQucGxhY2Vob2xkZXIucmVwbGFjZShcIkN1cnJlbnQ6IFwiLCBcIlwiKTsgLy8gVXNlIGN1cnJlbnQgcGF0aCBpZiBlbXB0eVxuXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5wdXRzKG5hbWUsIHBhdGgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgcmVwb3NpdG9yaWVzIGRhdGFcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZ2V0UmVwb3NEYXRhKCk7XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSBleHBlY3RlZCBkYXRhIHN0cnVjdHVyZVxuICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8ICFkYXRhLnJlcG9zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVwb3NpdG9yeSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCJDdXJyZW50IHJlcG9zaXRvcmllczpcIiwgZGF0YS5yZXBvcyk7IC8vIERlYnVnIGxvZ1xuICAgICAgY29uc29sZS5sb2coXCJMb29raW5nIGZvciByZXBvc2l0b3J5IHdpdGggbmFtZTpcIiwgb3JpZ2luYWxOYW1lKTsgLy8gRGVidWcgbG9nXG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSByZXBvc2l0b3J5IGV4aXN0c1xuICAgICAgaWYgKCFkYXRhLnJlcG9zW29yaWdpbmFsTmFtZV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlcG9zaXRvcnkgbm90IGZvdW5kIGluOlwiLCBkYXRhLnJlcG9zKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVwb3NpdG9yeSBub3QgZm91bmRcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIG5hbWUgaXMgYmVpbmcgY2hhbmdlZCB0byBhbiBleGlzdGluZyBvbmUgKGV4Y2VwdCBjdXJyZW50IHJlcG8pXG4gICAgICBpZiAobmFtZSAhPT0gb3JpZ2luYWxOYW1lICYmIGRhdGEucmVwb3NbbmFtZV0pIHtcbiAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgICAgXCJBIHJlcG9zaXRvcnkgd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHNcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHJlcG9zaXRvcmllc1xuICAgICAgY29uc3QgdXBkYXRlZFJlcG9zID0geyAuLi5kYXRhLnJlcG9zIH07XG5cbiAgICAgIC8vIElmIG5hbWUgY2hhbmdlZCwgcmVtb3ZlIG9sZCBlbnRyeVxuICAgICAgaWYgKG5hbWUgIT09IG9yaWdpbmFsTmFtZSkge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFJlcG9zW29yaWdpbmFsTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBvciBhZGQgdGhlIHJlcG9zaXRvcnkgd2l0aCBuZXcgdmFsdWVzIGFuZCB1cGRhdGVkQXQgdGltZXN0YW1wXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB1cGRhdGVkUmVwb3NbbmFtZV0gPSB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHVwZGF0ZWRBdDogZGF0YS5yZXBvc1tvcmlnaW5hbE5hbWVdPy51cGRhdGVkQXQgfHwgbm93LFxuICAgICAgfTtcblxuICAgICAgLy8gU2F2ZSB0aGUgdXBkYXRlZCByZXBvc2l0b3JpZXMgdXNpbmcgdGhlIGNvcnJlY3QgSVBDIG1ldGhvZFxuICAgICAgYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLndyaXRlUmVwb3NGaWxlKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgcmVwb3M6IHVwZGF0ZWRSZXBvcyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWZyZXNoIFVJXG4gICAgICBVSU1hbmFnZXIucmVmcmVzaCgpO1xuXG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKFwiUmVwb3NpdG9yeSB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwZGF0aW5nIHJlcG9zaXRvcnk6XCIsIGVycm9yKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHVwZGF0ZSByZXBvc2l0b3J5OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZUlucHV0cyhuYW1lLCBwYXRoKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBlbnRlciBhIHJlcG9zaXRvcnkgbmFtZVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBzZWxlY3QgYSByZXBvc2l0b3J5IHBhdGhcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgYnJvd3NlUGF0aCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF0aCA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5vcGVuRGlyZWN0b3J5RGlhbG9nKCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB0aGlzLnBhdGhJbnB1dC52YWx1ZSA9IHBhdGg7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRXJyb3Igc2VsZWN0aW5nIGRpcmVjdG9yeTogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFZGl0IENvbGxlY3Rpb24gTW9kYWxcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jbGFzcyBFZGl0Q29sbGVjdGlvbk1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImVkaXQtY29sbGVjdGlvbi1tb2RhbFwiLCBcImVkaXQtY29sbGVjdGlvbi1mb3JtXCIpO1xuICAgIHRoaXMubmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlZGl0LWNvbGxlY3Rpb24tbmFtZVwiKTtcbiAgICB0aGlzLm9yaWdpbmFsTmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICBcImVkaXQtb3JpZ2luYWwtY29sbGVjdGlvbi1uYW1lXCJcbiAgICApO1xuICAgIHRoaXMuY3VycmVudE5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3VycmVudC1jb2xsZWN0aW9uLW5hbWVcIik7XG4gICAgdGhpcy5jdXJyZW50UmVwb3NFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3VycmVudC1jb2xsZWN0aW9uLXJlcG9zXCIpO1xuICAgIHRoaXMucmVwb3NTZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtcmVwb3Mtc2VsZWN0aW9uXCIpO1xuICAgIHRoaXMuY2xvc2VCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2VkaXQtY29sbGVjdGlvbi1tb2RhbCAuY2xvc2VcIik7XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgfVxuXG4gIGFzeW5jIG9wZW4oY29sbGVjdGlvbikge1xuICAgIC8vIFN0b3JlIG9yaWdpbmFsIHZhbHVlc1xuICAgIHRoaXMub3JpZ2luYWxOYW1lSW5wdXQudmFsdWUgPSBjb2xsZWN0aW9uLm5hbWU7XG5cbiAgICAvLyBTZXQgY3VycmVudCB2YWx1ZXNcbiAgICB0aGlzLmN1cnJlbnROYW1lRWwudGV4dENvbnRlbnQgPSBjb2xsZWN0aW9uLm5hbWU7XG5cbiAgICAvLyBIYW5kbGUgYm90aCBhcnJheSBhbmQgc3RyaW5nIGZvcm1hdHMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBjb25zdCByZXBvTGlzdCA9IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbi5yZXBvcylcbiAgICAgID8gY29sbGVjdGlvbi5yZXBvc1xuICAgICAgOiAoY29sbGVjdGlvbi5yZXBvcyB8fCBcIlwiKVxuICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAubWFwKChzKSA9PiBzLnRyaW0oKSlcbiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgdGhpcy5jdXJyZW50UmVwb3NFbC50ZXh0Q29udGVudCA9IHJlcG9MaXN0Lmxlbmd0aFxuICAgICAgPyByZXBvTGlzdC5qb2luKFwiLCBcIilcbiAgICAgIDogXCJObyByZXBvc2l0b3JpZXNcIjtcbiAgICB0aGlzLm5hbWVJbnB1dC52YWx1ZSA9IGNvbGxlY3Rpb24ubmFtZTtcbiAgICB0aGlzLm5hbWVJbnB1dC5wbGFjZWhvbGRlciA9IGBDdXJyZW50OiAke2NvbGxlY3Rpb24ubmFtZX1gO1xuXG4gICAgLy8gTG9hZCByZXBvc2l0b3JpZXMgd2l0aCBjdXJyZW50IHNlbGVjdGlvblxuICAgIGF3YWl0IHRoaXMubG9hZFJlcG9zaXRvcmllcyhyZXBvTGlzdCk7XG5cbiAgICAvLyBPcGVuIG1vZGFsIGFuZCBmb2N1c1xuICAgIHN1cGVyLm9wZW4oKTtcbiAgICB0aGlzLm5hbWVJbnB1dC5mb2N1cygpO1xuICB9XG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmZvcm0/LmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKGUpID0+IHRoaXMuaGFuZGxlU3VibWl0KGUpKTtcblxuICAgIHRoaXMuY2xvc2VCdG4/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmNsb3NlKCkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFJlcG9zaXRvcmllcyhzZWxlY3RlZFJlcG9zID0gW10pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcbiAgICAgIHRoaXMucmVuZGVyUmVwb3NpdG9yeVNlbGVjdGlvbihkYXRhLnJlcG9zIHx8IHt9LCBzZWxlY3RlZFJlcG9zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBsb2FkaW5nIHJlcG9zaXRvcmllczogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9XG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZXJyb3JcIj5FcnJvciBsb2FkaW5nIHJlcG9zaXRvcmllcy4gUGxlYXNlIHRyeSBhZ2Fpbi48L2Rpdj4nO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlclJlcG9zaXRvcnlTZWxlY3Rpb24ocmVwb3MsIHNlbGVjdGVkUmVwb3MgPSBbXSkge1xuICAgIGlmICghcmVwb3MgfHwgT2JqZWN0LmtleXMocmVwb3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPVxuICAgICAgICAnPGRpdiBjbGFzcz1cImxvYWRpbmdcIj5ObyByZXBvc2l0b3JpZXMgZm91bmQuIEFkZCByZXBvc2l0b3JpZXMgZmlyc3QuPC9kaXY+JztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXBvc0xpc3QgPSBPYmplY3QuZW50cmllcyhyZXBvcylcbiAgICAgIC5zb3J0KChbbmFtZUFdLCBbbmFtZUJdKSA9PiBuYW1lQS5sb2NhbGVDb21wYXJlKG5hbWVCKSlcbiAgICAgIC5tYXAoXG4gICAgICAgIChbbmFtZSwgcmVwb10pID0+IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlcG8tY2hlY2tib3gtaXRlbVwiPlxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImVkaXQtcmVwby0ke25hbWV9XCIgbmFtZT1cInJlcG9zXCIgdmFsdWU9XCIke25hbWV9XCIgXG4gICAgICAgICAgICAgICAgICR7c2VsZWN0ZWRSZXBvcy5pbmNsdWRlcyhuYW1lKSA/IFwiY2hlY2tlZFwiIDogXCJcIn0+XG4gICAgICAgICAgPGxhYmVsIGZvcj1cImVkaXQtcmVwby0ke25hbWV9XCI+XG4gICAgICAgICAgICA8c3Bhbj4ke25hbWV9PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJyZXBvLXBhdGhcIj4ke3JlcG8ucGF0aH08L3NwYW4+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgXG4gICAgICApXG4gICAgICAuam9pbihcIlwiKTtcblxuICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID0gcmVwb3NMaXN0O1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlU3VibWl0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSB0aGlzLm9yaWdpbmFsTmFtZUlucHV0LnZhbHVlO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVJbnB1dC52YWx1ZS50cmltKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRSZXBvcyA9IHRoaXMuZ2V0U2VsZWN0ZWRSZXBvc2l0b3JpZXMoKTtcblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cyhuYW1lLCBzZWxlY3RlZFJlcG9zKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZ2V0UmVwb3NEYXRhKCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIG5hbWUgaXMgYmVpbmcgY2hhbmdlZCB0byBhbiBleGlzdGluZyBvbmUgKGV4Y2VwdCBjdXJyZW50IGNvbGxlY3Rpb24pXG4gICAgICBpZiAobmFtZSAhPT0gb3JpZ2luYWxOYW1lICYmIGRhdGEuY29sbGVjdGlvbnMgJiYgZGF0YS5jb2xsZWN0aW9uc1tuYW1lXSkge1xuICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgICBcIkEgY29sbGVjdGlvbiB3aXRoIHRoaXMgbmFtZSBhbHJlYWR5IGV4aXN0c1wiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbnNcbiAgICAgIGNvbnN0IHVwZGF0ZWRDb2xsZWN0aW9ucyA9IHsgLi4uZGF0YS5jb2xsZWN0aW9ucyB9O1xuXG4gICAgICAvLyBSZW1vdmUgb2xkIGVudHJ5IGlmIG5hbWUgY2hhbmdlZFxuICAgICAgaWYgKG5hbWUgIT09IG9yaWdpbmFsTmFtZSkge1xuICAgICAgICBkZWxldGUgdXBkYXRlZENvbGxlY3Rpb25zW29yaWdpbmFsTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBvciBhZGQgdGhlIGNvbGxlY3Rpb24gd2l0aCBuZXcgdmFsdWVzXG4gICAgICB1cGRhdGVkQ29sbGVjdGlvbnNbbmFtZV0gPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHJlcG9zOiBzZWxlY3RlZFJlcG9zLCAvLyBTYXZlIGFzIGFycmF5XG4gICAgICAgIHVwZGF0ZWRBdDpcbiAgICAgICAgICB1cGRhdGVkQ29sbGVjdGlvbnNbb3JpZ2luYWxOYW1lXT8udXBkYXRlZEF0IHx8XG4gICAgICAgICAgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgLy8gU2F2ZSB0aGUgdXBkYXRlZCBjb2xsZWN0aW9uc1xuICAgICAgYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLndyaXRlUmVwb3NGaWxlKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgY29sbGVjdGlvbnM6IHVwZGF0ZWRDb2xsZWN0aW9ucyxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKFwiQ29sbGVjdGlvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgIFVJTWFuYWdlci5yZWZyZXNoKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBjb2xsZWN0aW9uOlwiLCBlcnJvcik7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byB1cGRhdGUgY29sbGVjdGlvbjogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2VsZWN0ZWRSZXBvc2l0b3JpZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oXG4gICAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXTpjaGVja2VkJylcbiAgICApLm1hcCgoY2hlY2tib3gpID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgfVxuXG4gIHZhbGlkYXRlSW5wdXRzKG5hbWUsIHNlbGVjdGVkUmVwb3MpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIGVudGVyIGEgY29sbGVjdGlvbiBuYW1lXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZFJlcG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSByZXBvc2l0b3J5XCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb2xsZWN0aW9uIE1vZGFsXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgQ29sbGVjdGlvbk1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImFkZC1jb2xsZWN0aW9uLW1vZGFsXCIsIFwiYWRkLWNvbGxlY3Rpb24tZm9ybVwiLCBcImFkZC1jb2xsZWN0aW9uLWJ0blwiKTtcbiAgICB0aGlzLm5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29sbGVjdGlvbi1uYW1lXCIpO1xuICAgIHRoaXMucmVwb3NTZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcG9zLXNlbGVjdGlvblwiKTtcblxuICAgIHRoaXMuYmluZENvbGxlY3Rpb25FdmVudHMoKTtcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICB0aGlzLm5hbWVJbnB1dC5mb2N1cygpO1xuICAgIGF3YWl0IHRoaXMubG9hZFJlcG9zaXRvcmllcygpO1xuICB9XG5cbiAgb25DbG9zZSgpIHtcbiAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9XG4gICAgICAnPGRpdiBjbGFzcz1cImxvYWRpbmdcIj5Mb2FkaW5nIHJlcG9zaXRvcmllcy4uLjwvZGl2Pic7XG4gIH1cblxuICBiaW5kQ29sbGVjdGlvbkV2ZW50cygpIHtcbiAgICB0aGlzLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZSkgPT4gdGhpcy5oYW5kbGVTdWJtaXQoZSkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFJlcG9zaXRvcmllcygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcbiAgICAgIHRoaXMucmVuZGVyUmVwb3NpdG9yeVNlbGVjdGlvbihkYXRhLnJlcG9zIHx8IHt9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBsb2FkaW5nIHJlcG9zaXRvcmllczogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9XG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZXJyb3JcIj5FcnJvciBsb2FkaW5nIHJlcG9zaXRvcmllcy4gUGxlYXNlIHRyeSBhZ2Fpbi48L2Rpdj4nO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlclJlcG9zaXRvcnlTZWxlY3Rpb24ocmVwb3MpIHtcbiAgICBpZiAoIXJlcG9zIHx8IE9iamVjdC5rZXlzKHJlcG9zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJsb2FkaW5nXCI+Tm8gcmVwb3NpdG9yaWVzIGZvdW5kLiBBZGQgcmVwb3NpdG9yaWVzIGZpcnN0LjwvZGl2Pic7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVwb3NMaXN0ID0gT2JqZWN0LmVudHJpZXMocmVwb3MpXG4gICAgICAuc29ydCgoW25hbWVBXSwgW25hbWVCXSkgPT4gbmFtZUEubG9jYWxlQ29tcGFyZShuYW1lQikpXG4gICAgICAubWFwKFxuICAgICAgICAoW25hbWUsIHJlcG9dKSA9PiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyZXBvLWNoZWNrYm94LWl0ZW1cIj5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJyZXBvLSR7bmFtZX1cIiBuYW1lPVwicmVwb3NcIiB2YWx1ZT1cIiR7bmFtZX1cIj5cbiAgICAgICAgICA8bGFiZWwgZm9yPVwicmVwby0ke25hbWV9XCI+XG4gICAgICAgICAgICA8c3Bhbj4ke25hbWV9PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJyZXBvLXBhdGhcIj4ke3JlcG8ucGF0aH08L3NwYW4+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgXG4gICAgICApXG4gICAgICAuam9pbihcIlwiKTtcblxuICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID0gcmVwb3NMaXN0O1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlU3VibWl0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lSW5wdXQudmFsdWUudHJpbSgpO1xuICAgIGNvbnN0IHNlbGVjdGVkUmVwb3MgPSB0aGlzLmdldFNlbGVjdGVkUmVwb3NpdG9yaWVzKCk7XG5cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVJbnB1dHMobmFtZSwgc2VsZWN0ZWRSZXBvcykpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmVDb2xsZWN0aW9uKG5hbWUsIHNlbGVjdGVkUmVwb3MpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhcIkNvbGxlY3Rpb24gY3JlYXRlZCBzdWNjZXNzZnVsbHkhXCIpO1xuICAgICAgVUlNYW5hZ2VyLnJlZnJlc2goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBjcmVhdGluZyBjb2xsZWN0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXRTZWxlY3RlZFJlcG9zaXRvcmllcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnKVxuICAgICkubWFwKChjaGVja2JveCkgPT4gY2hlY2tib3gudmFsdWUpO1xuICB9XG5cbiAgdmFsaWRhdGVJbnB1dHMobmFtZSwgc2VsZWN0ZWRSZXBvcykge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2UgZW50ZXIgYSBjb2xsZWN0aW9uIG5hbWVcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkUmVwb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIHJlcG9zaXRvcnlcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBzYXZlQ29sbGVjdGlvbihuYW1lLCBzZWxlY3RlZFJlcG9zKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcblxuICAgIGlmIChkYXRhLmNvbGxlY3Rpb25zICYmIGRhdGEuY29sbGVjdGlvbnNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgY29sbGVjdGlvbiB3aXRoIHRoaXMgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEuY29sbGVjdGlvbnMpIGRhdGEuY29sbGVjdGlvbnMgPSB7fTtcbiAgICBkYXRhLmNvbGxlY3Rpb25zW25hbWVdID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHJlcG9zOiBzZWxlY3RlZFJlcG9zLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS53cml0ZVJlcG9zRmlsZShkYXRhKTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVUkgTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IFVJTWFuYWdlciA9IHtcbiAgaW5pdChjYWxsYmFja3MgPSB7fSkge1xuICAgIHRoaXMuc2VhcmNoSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaC1pbnB1dFwiKTtcbiAgICB0aGlzLnJlZnJlc2hCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlZnJlc2gtYnRuXCIpO1xuXG4gICAgLy8gU3RvcmUgY2FsbGJhY2tzXG4gICAgdGhpcy5oYW5kbGVFZGl0UmVwb3NpdG9yeSA9IGNhbGxiYWNrcy5vbkVkaXRSZXBvc2l0b3J5IHx8ICgoKSA9PiB7fSk7XG4gICAgdGhpcy5oYW5kbGVFZGl0Q29sbGVjdGlvbiA9IGNhbGxiYWNrcy5vbkVkaXRDb2xsZWN0aW9uIHx8ICgoKSA9PiB7fSk7XG5cbiAgICAvLyBJbml0aWFsaXplIGVkaXQgY29sbGVjdGlvbiBtb2RhbCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCF0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwpIHtcbiAgICAgIHRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbCA9IG5ldyBFZGl0Q29sbGVjdGlvbk1vZGFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICAvLyBEZWJvdW5jZSBzZWFyY2ggdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuICAgIGNvbnN0IGRlYm91bmNlZFVwZGF0ZSA9IFV0aWxzLmRlYm91bmNlKCgpID0+IHRoaXMudXBkYXRlRGlzcGxheSgpLCAzMDApO1xuICAgIHRoaXMuc2VhcmNoSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGRlYm91bmNlZFVwZGF0ZSk7XG4gICAgdGhpcy5yZWZyZXNoQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gIH0sXG5cbiAgYXN5bmMgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnNob3dSZWZyZXNoQW5pbWF0aW9uKCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcbiAgICAgIHRoaXMucHJvY2Vzc0RhdGEoZGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoYEVycm9yIHJlZnJlc2hpbmcgZGF0YTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmhpZGVSZWZyZXNoQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIHByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAvLyBQcm9jZXNzIHJlcG9zaXRvcmllc1xuICAgIGlmIChkYXRhLnJlcG9zKSB7XG4gICAgICBjb25zdCByZXBvcyA9IE9iamVjdC5lbnRyaWVzKGRhdGEucmVwb3MpLm1hcCgoW25hbWUsIHJlcG9dKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBwYXRoOiByZXBvLnBhdGgsXG4gICAgICAgIHVwZGF0ZWRBdDogcmVwby51cGRhdGVkQXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSkpO1xuICAgICAgQXBwU3RhdGUuc2V0UmVwb3MocmVwb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBBcHBTdGF0ZS5zZXRSZXBvcyhbXSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBjb2xsZWN0aW9uc1xuICAgIGlmIChkYXRhLmNvbGxlY3Rpb25zKSB7XG4gICAgICBjb25zdCBjb2xsZWN0aW9ucyA9IE9iamVjdC52YWx1ZXMoZGF0YS5jb2xsZWN0aW9ucykubWFwKChjb2xsZWN0aW9uKSA9PiAoe1xuICAgICAgICBuYW1lOiBjb2xsZWN0aW9uLm5hbWUsXG4gICAgICAgIHJlcG9zOiBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24ucmVwb3MpXG4gICAgICAgICAgPyBjb2xsZWN0aW9uLnJlcG9zLmpvaW4oXCIsIFwiKVxuICAgICAgICAgIDogXCJcIixcbiAgICAgICAgdXBkYXRlZEF0OiBjb2xsZWN0aW9uLnVwZGF0ZWRBdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KSk7XG4gICAgICBBcHBTdGF0ZS5zZXRDb2xsZWN0aW9ucyhjb2xsZWN0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFwcFN0YXRlLnNldENvbGxlY3Rpb25zKFtdKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlRGlzcGxheSgpIHtcbiAgICBjb25zdCBzZWFyY2hUZXJtID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZS50cmltKCk7XG4gICAgdGhpcy51cGRhdGVSZXBvc2l0b3JpZXNUYWJsZShBcHBTdGF0ZS5nZXRGaWx0ZXJlZFJlcG9zKHNlYXJjaFRlcm0pKTtcbiAgICB0aGlzLnVwZGF0ZUNvbGxlY3Rpb25zVGFibGUoQXBwU3RhdGUuZ2V0RmlsdGVyZWRDb2xsZWN0aW9ucyhzZWFyY2hUZXJtKSk7XG4gIH0sXG5cbiAgdXBkYXRlUmVwb3NpdG9yaWVzVGFibGUocmVwb3MpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcG9zLWxpc3RcIik7XG4gICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcG9zLXRhYmxlXCIpO1xuICAgIGNvbnN0IGxvYWRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmctcmVwb3NcIik7XG5cbiAgICBpZiAocmVwb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2FkaW5nLnRleHRDb250ZW50ID0gXCJObyBtYXRjaGluZyByZXBvc2l0b3JpZXMgZm91bmQuXCI7XG4gICAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICB0YWJsZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgdGFibGUuc3R5bGUuZGlzcGxheSA9IFwidGFibGVcIjtcblxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSByZXBvc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSkpXG4gICAgICAubWFwKChyZXBvKSA9PiB0aGlzLmNyZWF0ZVJlcG9zaXRvcnlSb3cocmVwbykpXG4gICAgICAuam9pbihcIlwiKTtcblxuICAgIHRoaXMuYmluZFJlcG9zaXRvcnlFdmVudHMoKTtcbiAgfSxcblxuICBjcmVhdGVSZXBvc2l0b3J5Um93KHJlcG8pIHtcbiAgICByZXR1cm4gYFxuICAgICAgPHRyIGRhdGEtcGF0aD1cIiR7VXRpbHMuZm9ybWF0UGF0aChyZXBvLnBhdGgpfVwiIGRhdGEtbmFtZT1cIiR7cmVwby5uYW1lfVwiIGNsYXNzPVwiY2xpY2thYmxlLXJlcG8tcm93XCI+XG4gICAgICAgIDx0ZD48c3Ryb25nPiR7cmVwby5uYW1lfTwvc3Ryb25nPjwvdGQ+XG4gICAgICAgIDx0ZCBjbGFzcz1cInBhdGhcIj4ke1V0aWxzLmZvcm1hdFBhdGgocmVwby5wYXRoKX08L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJhY3Rpb25zXCI+XG4gICAgICAgICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGdhcDogNXB4XCI+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZWRpdC1idG5cIiBkYXRhLW5hbWU9XCIke3JlcG8ubmFtZX1cIiBkYXRhLXBhdGg9XCIke1V0aWxzLmZvcm1hdFBhdGgocmVwby5wYXRoKX1cIiBkYXRhLXR5cGU9XCJyZXBvXCIgdGl0bGU9XCJFZGl0IHJlcG9zaXRvcnlcIj7inI/vuI88L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkZWxldGUtYnRuXCIgZGF0YS1uYW1lPVwiJHtyZXBvLm5hbWV9XCIgZGF0YS10eXBlPVwicmVwb1wiIHRpdGxlPVwiRGVsZXRlIHJlcG9zaXRvcnlcIj7wn5eR77iPPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvdGQ+XG4gICAgICA8L3RyPlxuICAgIGA7XG4gIH0sXG5cbiAgYmluZFJlcG9zaXRvcnlFdmVudHMoKSB7XG4gICAgLy8gQmluZCBjbGljayBldmVudHMgZm9yIG9wZW5pbmcgcmVwb3NpdG9yaWVzXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jbGlja2FibGUtcmVwby1yb3dcIikuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICByb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB0aGlzLmhhbmRsZVJlcG9zaXRvcnlDbGljayhlLCByb3cpKTtcbiAgICB9KTtcblxuICAgIC8vIEJpbmQgZWRpdCBldmVudHNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWRpdC1idG5bZGF0YS10eXBlPVwicmVwb1wiXScpLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBuYW1lID0gYnRuLmRhdGFzZXQubmFtZTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGJ0bi5kYXRhc2V0LnBhdGg7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZUVkaXRSZXBvc2l0b3J5KSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFZGl0UmVwb3NpdG9yeSh7IG5hbWUsIHBhdGggfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQmluZCBkZWxldGUgZXZlbnRzXG4gICAgZG9jdW1lbnRcbiAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVsZXRlLWJ0bltkYXRhLXR5cGU9XCJyZXBvXCJdJylcbiAgICAgIC5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT5cbiAgICAgICAgICB0aGlzLmhhbmRsZVJlcG9zaXRvcnlEZWxldGUoZSwgYnRuKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgYXN5bmMgaGFuZGxlUmVwb3NpdG9yeUNsaWNrKGUsIHJvdykge1xuICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSBcIkJVVFRPTlwiKSByZXR1cm47XG5cbiAgICBjb25zdCBzZWxlY3RlZElERSA9IElERU1hbmFnZXIuZ2V0U2VsZWN0ZWRJREUoKTtcbiAgICBpZiAoIXNlbGVjdGVkSURFKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBzZWxlY3QgYW4gSURFIGZpcnN0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcG9QYXRoID0gcm93LmdldEF0dHJpYnV0ZShcImRhdGEtcGF0aFwiKTtcbiAgICBjb25zdCByZXBvTmFtZSA9IHJvdy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5hbWVcIik7XG4gICAgY29uc29sZS5sb2cocmVwb1BhdGgsIHJlcG9OYW1lKTtcbiAgICBpZiAoIXJlcG9QYXRoKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLm9wZW5JbklERSh7XG4gICAgICAgIG5hbWU6IHJlcG9OYW1lLFxuICAgICAgICBwYXRoOiByZXBvUGF0aCxcbiAgICAgICAgaWRlOiBzZWxlY3RlZElERSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IgfHwgXCJGYWlsZWQgdG8gb3BlbiBpbiBJREVcIik7XG4gICAgICB9XG5cbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXG4gICAgICAgIGBTdWNjZXNzZnVsbHkgb3BlbmVkICR7cmVwb1BhdGh9IGluICR7c2VsZWN0ZWRJREV9YFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoYEVycm9yIG9wZW5pbmcgSURFOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIGhhbmRsZVJlcG9zaXRvcnlEZWxldGUoZSwgYnRuKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IG5hbWUgPSBidG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIpO1xuICAgIC8vIGlmICghY29uZmlybShgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSByZXBvc2l0b3J5IFwiJHtuYW1lfVwiP2ApKVxuICAgIC8vICAgcmV0dXJuO1xuXG4gICAgY29uc3QgbG9hZGluZ0VsID0gdGhpcy5zaG93TG9hZGluZ0luZGljYXRvcihcIkRlbGV0aW5nLi4uXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5kZWxldGVSZXBvKG5hbWUpO1xuXG4gICAgICBpZiAocmVzdWx0Py5zdWNjZXNzKSB7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Py5lcnJvciB8fCBcIlVua25vd24gZXJyb3JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKGBFcnJvciBkZWxldGluZyAke25hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaGlkZUxvYWRpbmdJbmRpY2F0b3IobG9hZGluZ0VsKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlQ29sbGVjdGlvbnNUYWJsZShjb2xsZWN0aW9ucykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29sbGVjdGlvbnMtbGlzdFwiKTtcbiAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29sbGVjdGlvbnMtdGFibGVcIik7XG4gICAgY29uc3QgbG9hZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGluZy1jb2xsZWN0aW9uc1wiKTtcblxuICAgIGlmIChjb2xsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvYWRpbmcudGV4dENvbnRlbnQgPSBcIk5vIG1hdGNoaW5nIGNvbGxlY3Rpb25zIGZvdW5kLlwiO1xuICAgICAgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGFibGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHRhYmxlLnN0eWxlLmRpc3BsYXkgPSBcInRhYmxlXCI7XG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gY29sbGVjdGlvbnNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKVxuICAgICAgLm1hcCgoY29sbGVjdGlvbikgPT4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uUm93KGNvbGxlY3Rpb24pKVxuICAgICAgLmpvaW4oXCJcIik7XG5cbiAgICB0aGlzLmJpbmRDb2xsZWN0aW9uRXZlbnRzKCk7XG4gIH0sXG5cbiAgY3JlYXRlQ29sbGVjdGlvblJvdyhjb2xsZWN0aW9uKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbkRhdGEgPSBKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKTtcbiAgICByZXR1cm4gYFxuICAgICAgPHRyIGNsYXNzPVwiY2xpY2thYmxlLWNvbGxlY3Rpb24tcm93XCIgZGF0YS1jb2xsZWN0aW9uPVwiJHtjb2xsZWN0aW9uRGF0YX1cIj5cbiAgICAgICAgPHRkPjxzdHJvbmc+JHtjb2xsZWN0aW9uLm5hbWV9PC9zdHJvbmc+PC90ZD5cbiAgICAgICAgPHRkPiR7Y29sbGVjdGlvbi5yZXBvc308L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJhY3Rpb25zXCI+XG4gICAgICAgICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGdhcDogNXB4XCI+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZWRpdC1idG5cIiBkYXRhLW5hbWU9XCIke2NvbGxlY3Rpb24ubmFtZX1cIiBkYXRhLXR5cGU9XCJjb2xsZWN0aW9uXCIgdGl0bGU9XCJFZGl0IGNvbGxlY3Rpb25cIj7inI/vuI88L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkZWxldGUtYnRuXCIgZGF0YS1uYW1lPVwiJHtjb2xsZWN0aW9uLm5hbWV9XCIgZGF0YS10eXBlPVwiY29sbGVjdGlvblwiIHRpdGxlPVwiRGVsZXRlIGNvbGxlY3Rpb25cIj7wn5eR77iPPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvdGQ+XG4gICAgICA8L3RyPlxuICAgIGA7XG4gIH0sXG5cbiAgYmluZENvbGxlY3Rpb25FdmVudHMoKSB7XG4gICAgLy8gQmluZCBjbGljayBldmVudHMgZm9yIG9wZW5pbmcgY29sbGVjdGlvbnNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNsaWNrYWJsZS1jb2xsZWN0aW9uLXJvd1wiKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHRoaXMuaGFuZGxlQ29sbGVjdGlvbkNsaWNrKGUsIHJvdykpO1xuICAgIH0pO1xuXG4gICAgLy8gQmluZCBlZGl0IGV2ZW50c1xuICAgIGRvY3VtZW50XG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLmVkaXQtYnRuW2RhdGEtdHlwZT1cImNvbGxlY3Rpb25cIl0nKVxuICAgICAgLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uRGF0YSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICBidG5cbiAgICAgICAgICAgICAgLmNsb3Nlc3QoXCJ0clwiKVxuICAgICAgICAgICAgICAuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xsZWN0aW9uXCIpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbC5vcGVuKGNvbGxlY3Rpb25EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAvLyBCaW5kIGRlbGV0ZSBldmVudHNcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZWxldGUtYnRuW2RhdGEtdHlwZT1cImNvbGxlY3Rpb25cIl0nKVxuICAgICAgLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PlxuICAgICAgICAgIHRoaXMuaGFuZGxlQ29sbGVjdGlvbkRlbGV0ZShlLCBidG4pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgfSxcblxuICBhc3luYyBoYW5kbGVDb2xsZWN0aW9uQ2xpY2soZSwgcm93KSB7XG4gICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQlVUVE9OXCIpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb2xsZWN0aW9uID0gSlNPTi5wYXJzZShyb3cuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xsZWN0aW9uXCIpKTtcbiAgICAgIGNvbnN0IHJlcG9zRGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcblxuICAgICAgY29uc3QgcmVwb3MgPSBjb2xsZWN0aW9uLnJlcG9zLnNwbGl0KFwiLFwiKS5tYXAoKHJlcG8pID0+IHtcbiAgICAgICAgY29uc3QgW25hbWUsIHBhdGgsIGlkZV0gPSByZXBvXG4gICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgIC5zcGxpdChcInxcIilcbiAgICAgICAgICAubWFwKChzKSA9PiBzLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIHBhdGgsIGlkZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE9wZW4gYWxsIHJlcG9zaXRvcmllcyBpbiBwYXJhbGxlbFxuICAgICAgY29uc3QgcHJvbWlzZXMgPSByZXBvcy5tYXAoYXN5bmMgKHJlcG8pID0+IHtcbiAgICAgICAgY29uc3QgcmVwb0RhdGEgPSByZXBvc0RhdGEucmVwb3NbcmVwby5uYW1lXTtcblxuICAgICAgICBpZiAoIXJlcG9EYXRhKSB7XG4gICAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgICAgICBgJHtyZXBvLm5hbWV9OiBOb3QgZm91bmQgaW4gcmVwb3NpdG9yaWVzYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWRlID0gcmVwby5pZGUgfHwgSURFTWFuYWdlci5nZXRTZWxlY3RlZElERSgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLm9wZW5JbklERSh7XG4gICAgICAgICAgICBuYW1lOiByZXBvLm5hbWUsXG4gICAgICAgICAgICBwYXRoOiByZXBvRGF0YS5wYXRoLFxuICAgICAgICAgICAgaWRlOiBpZGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIG9wZW4gJHtyZXBvLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhgU3VjY2Vzc2Z1bGx5IG9wZW5lZCAke2NvbGxlY3Rpb24ubmFtZX1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIGNvbGxlY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICBhc3luYyBoYW5kbGVDb2xsZWN0aW9uRGVsZXRlKGUsIGJ0bikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBuYW1lID0gYnRuLmdldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiKTtcbiAgICAvLyBpZiAoIWNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgY29sbGVjdGlvbiBcIiR7bmFtZX1cIj9gKSlcbiAgICAvLyAgIHJldHVybjtcblxuICAgIGNvbnN0IGxvYWRpbmdFbCA9IHRoaXMuc2hvd0xvYWRpbmdJbmRpY2F0b3IoXCJEZWxldGluZy4uLlwiKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZGVsZXRlQ29sbGVjdGlvbihuYW1lKTtcblxuICAgICAgaWYgKHJlc3VsdD8uc3VjY2Vzcykge1xuICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKGBTdWNjZXNzZnVsbHkgZGVsZXRlZCAke25hbWV9YCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdD8uZXJyb3IgfHwgXCJVbmtub3duIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihgRXJyb3IgZGVsZXRpbmcgJHtuYW1lfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmhpZGVMb2FkaW5nSW5kaWNhdG9yKGxvYWRpbmdFbCk7XG4gICAgfVxuICB9LFxuXG4gIHNob3dSZWZyZXNoQW5pbWF0aW9uKCkge1xuICAgIHRoaXMucmVmcmVzaEJ0bi5jbGFzc0xpc3QuYWRkKFwicm90YXRpbmdcIik7XG4gIH0sXG5cbiAgaGlkZVJlZnJlc2hBbmltYXRpb24oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlZnJlc2hCdG4uY2xhc3NMaXN0LnJlbW92ZShcInJvdGF0aW5nXCIpO1xuICAgIH0sIDEwMDApO1xuICB9LFxuXG4gIHNob3dMb2FkaW5nSW5kaWNhdG9yKHRleHQpIHtcbiAgICBjb25zdCBpbmRpY2F0b3IgPSBVdGlscy5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDEwcHg7XG4gICAgICAgIHJpZ2h0OiAxMHB4O1xuICAgICAgICBwYWRkaW5nOiAxMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuNyk7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgICAgYCxcbiAgICAgIH0sXG4gICAgICBbdGV4dF1cbiAgICApO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbmRpY2F0b3IpO1xuICAgIHJldHVybiBpbmRpY2F0b3I7XG4gIH0sXG5cbiAgaGlkZUxvYWRpbmdJbmRpY2F0b3IoaW5kaWNhdG9yKSB7XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMoaW5kaWNhdG9yKSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbmRpY2F0b3IpO1xuICAgIH1cbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBcHBsaWNhdGlvbiBJbml0aWFsaXphdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIEFwcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBJbml0aWFsaXplIGNvcmUgc3lzdGVtc1xuICAgIFRoZW1lTWFuYWdlci5pbml0KCk7XG4gICAgSURFTWFuYWdlci5pbml0KCk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1vZGFsc1xuICAgIHRoaXMucmVwb3NpdG9yeU1vZGFsID0gbmV3IFJlcG9zaXRvcnlNb2RhbCgpO1xuICAgIHRoaXMuZWRpdFJlcG9zaXRvcnlNb2RhbCA9IG5ldyBFZGl0UmVwb3NpdG9yeU1vZGFsKCk7XG4gICAgdGhpcy5jb2xsZWN0aW9uTW9kYWwgPSBuZXcgQ29sbGVjdGlvbk1vZGFsKCk7XG4gICAgdGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsID0gbmV3IEVkaXRDb2xsZWN0aW9uTW9kYWwoKTtcblxuICAgIC8vIEluaXRpYWxpemUgVUkgbWFuYWdlciB3aXRoIG1vZGFsc1xuICAgIFVJTWFuYWdlci5pbml0KHtcbiAgICAgIG9uRWRpdFJlcG9zaXRvcnk6IChyZXBvKSA9PiB0aGlzLmVkaXRSZXBvc2l0b3J5TW9kYWwub3BlbihyZXBvKSxcbiAgICAgIG9uRWRpdENvbGxlY3Rpb246IChjb2xsZWN0aW9uKSA9PlxuICAgICAgICB0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwub3Blbihjb2xsZWN0aW9uKSxcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBlbGVjdHJvbiBBUEkgZGF0YVxuICAgIHRoaXMuYmluZEVsZWN0cm9uRXZlbnRzKCk7XG5cbiAgICBjb25zb2xlLmxvZyhcIvCfkYsgT3Blbk1hdGUgYXBwbGljYXRpb24gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICB9XG5cbiAgYmluZEVsZWN0cm9uRXZlbnRzKCkge1xuICAgIGlmICh3aW5kb3cuZWxlY3Ryb25BUEkgJiYgd2luZG93LmVsZWN0cm9uQVBJLm9uUmVwb3NEYXRhKSB7XG4gICAgICB3aW5kb3cuZWxlY3Ryb25BUEkub25SZXBvc0RhdGEoKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXBvcyA9IFtdLCBjb2xsZWN0aW9ucyA9IFtdIH0gPSBkYXRhO1xuICAgICAgICBBcHBTdGF0ZS5zZXRSZXBvcyhyZXBvcyk7XG4gICAgICAgIEFwcFN0YXRlLnNldENvbGxlY3Rpb25zKGNvbGxlY3Rpb25zKTtcbiAgICAgICAgVUlNYW5hZ2VyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSW5pdGlhbGl6ZSBBcHBsaWNhdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgbmV3IEFwcCgpO1xufSk7XG5cbi8vIEltcG9ydCBzdHlsZXNcbmltcG9ydCBcIi4vaW5kZXguY3NzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/renderer.js\n\n}");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("d1b53704adfe7f4e0c60")
/******/ })();
/******/ 
/******/ }
);